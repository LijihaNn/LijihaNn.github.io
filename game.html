<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<title>GB 스타일 RPG — 통합판</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
<style>
  body { margin:0; background:#0f380f; color:#fff; font-family:monospace; }
  canvas { display:block; margin:0 auto; image-rendering:pixelated; }
  #uiTop {
    position: absolute; left: 10px; top: 8px; z-index: 1000;
    color: #fff; font-size: 14px;
  }
  #buttons {
    position: absolute; right: 10px; top: 8px; z-index:1000;
  }
  button { margin-left: 6px; font-size: 13px; padding:4px 6px; }
</style>
</head>
<body>

<div id="uiTop">Coins: <span id="coinCount">0</span>  |  Quest: <span id="questState">None</span></div>
<div id="buttons">
  <button id="btnInv">Inventory</button>
  <button id="btnSave">Save</button>
  <button id="btnLoad">Load</button>
</div>

<script>
/* ===========================
   설정 / 리소스 (스프라이트)
   =========================== */

/*
  업로드한 이미지 경로를 사용합니다.
  (대화에서 업로드한 파일 경로)
  필요하면 상대경로로 바꿔서 index.html과 같은 폴더에서 실행하세요.
*/
const SPRITE_PATH = "/mnt/data/d0f16d20706457179aa1535b5efbea73.jpg";

/* Phaser 설정 */
const GAME_WIDTH = 320;
const GAME_HEIGHT = 240;

const config = {
  type: Phaser.AUTO,
  width: GAME_WIDTH,
  height: GAME_HEIGHT,
  pixelArt: true,
  zoom: 2, // 2배 확대
  physics: { default: 'arcade', arcade: { gravity: { y: 0 }, debug: false } },
  scene: [BootScene, WorldScene, BattleScene, UIScene]
};

let game = new Phaser.Game(config);

/* ===========================
   BootScene: 리소스 로드
   =========================== */
function BootScene() { Phaser.Scene.call(this, { key: 'BootScene' }); }
BootScene.prototype = Object.create(Phaser.Scene.prototype);
BootScene.prototype.constructor = BootScene;

BootScene.prototype.preload = function() {
  // 스프라이트(업로드한 시트)
  this.load.spritesheet('hero', SPRITE_PATH, { frameWidth: 16, frameHeight: 16 });

  // 기본 타일(코드로 만들기)
  // 소리/효과는 생략 (추가 가능)
};

BootScene.prototype.create = function() {
  this.scene.start('WorldScene');
};

/* ===========================
   UIScene: 인벤토리/배수 UI
   =========================== */
function UIScene() { Phaser.Scene.call(this, { key:'UIScene', active:false }); }
UIScene.prototype = Object.create(Phaser.Scene.prototype);
UIScene.prototype.constructor = UIScene;

UIScene.prototype.create = function() {
  // 인벤토리 창을 DOM으로 간단히 만들기
  this.invOpen = false;
  this.invDiv = document.createElement('div');
  Object.assign(this.invDiv.style, { position:'absolute', left:'10px', top:'280px', zIndex:1000, color:'#fff', background:'rgba(0,0,0,0.6)', padding:'8px', fontFamily:'monospace', display:'none' });
  document.body.appendChild(this.invDiv);
  this.updateInv([]);
};

UIScene.prototype.updateInv = function(items) {
  this.invDiv.innerHTML = "<b>Inventory</b><br>";
  if (items.length === 0) this.invDiv.innerHTML += "(empty)";
  else items.forEach((it,i)=> this.invDiv.innerHTML += (i+1)+". "+it+"<br>");
};

UIScene.prototype.toggle = function(items) {
  this.invOpen = !this.invOpen;
  this.invDiv.style.display = this.invOpen ? 'block' : 'none';
  this.updateInv(items);
};

/* ===========================
   WorldScene: 마을/맵/대화/아이템/몬스터조우
   =========================== */
function WorldScene() { Phaser.Scene.call(this, { key:'WorldScene' }); }
WorldScene.prototype = Object.create(Phaser.Scene.prototype);
WorldScene.prototype.constructor = WorldScene;

WorldScene.prototype.create = function() {
  // 저장된 데이터 불러오기 (있으면)
  const saved = JSON.parse(localStorage.getItem('gb_rpg_save') || "null");
  this.state = {
    coins: saved ? saved.coins : 0,
    inventory: saved ? saved.inventory : [],
    quest: saved ? saved.quest : 'None',
    playerPos: saved ? saved.playerPos : { x: 5, y: 6 },
    stage: saved ? saved.stage : 'town'
  };

  // UI 업데이트
  document.getElementById('coinCount').innerText = this.state.coins;
  document.getElementById('questState').innerText = this.state.quest;

  // 카메라와 배경
  this.cameras.main.setBackgroundColor('#90D070');

  // 타일 매트릭스 생성
  this.createMaps();

  // 플레이어 스프라이트 (스프라이트 시트)
  this.player = this.physics.add.sprite(this.state.playerPos.x * 16, this.state.playerPos.y * 16, 'hero', 0);
  this.player.setCollideWorldBounds(true);
  this.player.speed = 60;

  // 애니메이션 (위/오른/왼/아래) — top row used
  this.createPlayerAnims();

  // 물리 충돌: world bounds by tile collision later
  this.physics.world.setBounds(0,0, this.mapWidth*16, this.mapHeight*16);

  // 카메라 따라오기
  this.cameras.main.startFollow(this.player, true, 0.08, 0.08);
  this.cameras.main.setBounds(0,0,this.mapWidth*16, this.mapHeight*16);

  // 충돌 블록들에 충돌 적용
  this.blockGroup = this.physics.add.staticGroup();
  for (let b of this.blocks) {
    let s = this.add.rectangle(b.x*16 + 8, b.y*16 + 8, 16, 16, 0x000000, 0);
    this.physics.add.existing(s, true);
    this.blockGroup.add(s);
  }
  this.physics.add.collider(this.player, this.blockGroup);

  // 아이템(코인) 그룹
  this.itemGroup = this.physics.add.group();
  for (let it of this.items) {
    let coin = this.physics.add.sprite(it.x*16 + 8, it.y*16 + 8, null).setSize(8,8).setTint(0xFFFF66);
    coin.custom = { key: it.key };
    coin.body.setAllowGravity(false);
    this.itemGroup.add(coin);
  }
  this.physics.add.overlap(this.player, this.itemGroup, this.pickItem, null, this);

  // NPC (B) 배치 (natural place)
  this.npc = this.physics.add.sprite(9*16, 5*16, 'hero', 4); // use second frame set as NPC appearance
  this.npc.body.setImmovable(true);
  this.npc.dialog = ["안녕, 여행자! 마을에 온 걸 환영해.", "숲에 가려면 준비해!"];
  this.physics.add.collider(this.player, this.npc);

  // 상호작용 키
  this.keys = this.input.keyboard.addKeys({ interact: Phaser.Input.Keyboard.KeyCodes.Z, inv: Phaser.Input.Keyboard.KeyCodes.I });

  // 랜덤 야생 조우 확률 구역 정의 (숲 진입 포인트)
  this.encounterZones = [{ x1: 15, y1: 1, x2: 22, y2: 6 }]; // 예: map coords

  // 버튼 루프 연결
  document.getElementById('btnInv').onclick = ()=> { this.scene.launch('UIScene'); this.scene.get('UIScene').toggle(this.state.inventory); };
  document.getElementById('btnSave').onclick = ()=> { this.saveGame(); alert('Saved'); };
  document.getElementById('btnLoad').onclick = ()=> { this.loadGame(); alert('Loaded'); };

  // 상점 영역 만들기 (집 앞)
  this.shopArea = new Phaser.Geom.Rectangle(3*16, 3*16, 2*16, 2*16);

  // 그리기 레이어
  this.graphics = this.add.graphics();
  this.drawMap();

  // 시간 이벤트: 자동 저장 주기
  this.time.addEvent({ delay: 8000, callback: this.saveGame, callbackScope: this, loop: true });
};

WorldScene.prototype.createMaps = function() {
  // 간단한 작은 마을 타일맵(숫자로 매핑)
  // 0 = grass, 1 = road, 2 = wall/tree
  this.map = [
    [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
    [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
    [2,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,0,0,2],
    [2,0,1,3,1,0,0,1,0,0,0,0,1,0,0,1,0,1,0,0,2],
    [2,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,1,0,0,2],
    [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
    [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]
  ];
  this.mapWidth = this.map[0].length;
  this.mapHeight = this.map.length;

  // 충돌 블록 좌표(예시)
  this.blocks = [];
  for (let y=0;y<this.mapHeight;y++) {
    for (let x=0;x<this.mapWidth;x++){
      if (this.map[y][x] === 2) this.blocks.push({x:x,y:y});
      if (this.map[y][x] === 3) { /* NPC tile placeholder */ }
    }
  }

  // 아이템 좌표 예시
  this.items = [{x:6,y:4,key:'coin'}, {x:12,y:2,key:'coin'}];
};

WorldScene.prototype.drawMap = function(){
  // draw tiles using colors (GB palette feel)
  this.graphics.clear();
  for (let y=0;y<this.mapHeight;y++){
    for (let x=0;x<this.mapWidth;x++){
      const t = this.map[y][x];
      let color = 0x88c070;
      if (t === 1) color = 0xc2b96a; // road
      if (t === 2) color = 0x0f380f; // wall/tree
      if (t === 3) color = 0xffd800; // npc spot
      this.graphics.fillStyle(color,1);
      this.graphics.fillRect(x*16, y*16, 16, 16);
    }
  }
};

WorldScene.prototype.createPlayerAnims = function(){
  // Assuming top row of uploaded sheet: 4 directions × 3 frames each (start frames 0,3,6,9)
  this.anims.create({ key:'walk-down', frames: this.anims.generateFrameNumbers('hero', { start:0, end:2 }), frameRate:8, repeat:-1 });
  this.anims.create({ key:'walk-right', frames: this.anims.generateFrameNumbers('hero', { start:3, end:5 }), frameRate:8, repeat:-1 });
  this.anims.create({ key:'walk-up', frames: this.anims.generateFrameNumbers('hero', { start:6, end:8 }), frameRate:8, repeat:-1 });
  this.anims.create({ key:'walk-left', frames: this.anims.generateFrameNumbers('hero', { start:9, end:11 }), frameRate:8, repeat:-1 });

  // Idle frames (use first frame of each dir)
  this.anims.create({ key:'idle-down', frames:[{key:'hero',frame:0}], frameRate:1 });
  this.anims.create({ key:'idle-right', frames:[{key:'hero',frame:3}], frameRate:1 });
  this.anims.create({ key:'idle-up', frames:[{key:'hero',frame:6}], frameRate:1 });
  this.anims.create({ key:'idle-left', frames:[{key:'hero',frame:9}], frameRate:1 });
};

WorldScene.prototype.pickItem = function(player, item) {
  // pick logic
  const key = item.custom.key;
  if (key === 'coin') {
    this.state.coins += 1;
    document.getElementById('coinCount').innerText = this.state.coins;
  } else {
    this.state.inventory.push(key);
    this.scene.get('UIScene').updateInv(this.state.inventory);
  }
  item.destroy();
};

WorldScene.prototype.update = function(time, delta) {
  // movement by arrow keys (grid-like as requested: tile steps)
  const speed = this.player.speed;
  const cursors = this.input.keyboard.createCursorKeys();

  let vx = 0, vy = 0;
  if (cursors.left.isDown) vx = -speed;
  else if (cursors.right.isDown) vx = speed;
  if (cursors.up.isDown) vy = -speed;
  else if (cursors.down.isDown) vy = speed;

  this.player.setVelocity(vx, vy);

  // play animation based on velocity
  if (vx < 0) this.player.anims.play('walk-left', true), this.lastDir='left';
  else if (vx > 0) this.player.anims.play('walk-right', true), this.lastDir='right';
  else if (vy < 0) this.player.anims.play('walk-up', true), this.lastDir='up';
  else if (vy > 0) this.player.anims.play('walk-down', true), this.lastDir='down';
  else if (this.lastDir) this.player.anims.play('idle-'+this.lastDir, true);

  // interaction: Z key for NPC/shop
  if (Phaser.Input.Keyboard.JustDown(this.keys.interact)) {
    const dist = Phaser.Math.Distance.Between(this.player.x, this.player.y, this.npc.x, this.npc.y);
    if (dist < 24) {
      this.showDialog(this.npc.dialog);
    } else {
      // check shop area
      if (this.shopArea.contains(this.player.x, this.player.y)) {
        this.openShop();
      }
    }
  }

  // check if in encounter zone (simple example)
  for (let z of this.encounterZones) {
    const tx = Math.floor(this.player.x/16), ty = Math.floor(this.player.y/16);
    if (tx >= z.x1 && tx <= z.x2 && ty >= z.y1 && ty <= z.y2) {
      if (Math.random() < 0.01) { // low prob per frame
        this.startEncounter();
      }
    }
  }
};

/* Dialogue implementation */
WorldScene.prototype.showDialog = function(lines) {
  // simple modal overlay with typing effect
  if (this.dialogOpen) return;
  this.dialogOpen = true;
  const overlay = this.add.rectangle(this.cameras.main.midPoint.x, this.cameras.main.midPoint.y+60, 260, 60, 0x081820, 0.9).setScrollFactor(0);
  const txt = this.add.text(this.cameras.main.midPoint.x - 120, this.cameras.main.midPoint.y+40, '', { font:'12px monospace', fill:'#E0F8D0' }).setScrollFactor(0);
  let idx=0, lineIdx=0;
  const showNextChar = ()=> {
    if (idx < lines[lineIdx].length) {
      txt.text += lines[lineIdx][idx++];
      this.time.delayedCall(40, showNextChar, [], this);
    } else {
      // wait for Z
    }
  };
  showNextChar();

  const onKey = (e)=> {
    if (e.key === 'z' || e.key === 'Z') {
      lineIdx++;
      if (lineIdx >= lines.length) {
        this.dialogOpen = false;
        overlay.destroy(); txt.destroy();
        window.removeEventListener('keydown', onKey);
      } else {
        txt.text = '';
        idx = 0;
        showNextChar();
      }
    }
  };
  window.addEventListener('keydown', onKey);
};

/* Shop */
WorldScene.prototype.openShop = function() {
  // simple buy dialog via prompt
  const shopItems = [{name:'Potion', price:3}, {name:'Revive', price:8}];
  let menu = 'Shop:\\n';
  shopItems.forEach((it,i)=> menu += `${i+1}. ${it.name} - ${it.price} coins\\n`);
  menu += '0. cancel';
  const choice = prompt(menu);
  const idx = parseInt(choice) - 1;
  if (idx >=0 && idx < shopItems.length) {
    const it = shopItems[idx];
    if (this.state.coins >= it.price) {
      this.state.coins -= it.price;
      this.state.inventory.push(it.name);
      this.scene.get('UIScene').updateInv(this.state.inventory);
      document.getElementById('coinCount').innerText = this.state.coins;
      alert('Purchased ' + it.name);
    } else alert('Not enough coins');
  }
};

/* Encounter -> BattleScene */
WorldScene.prototype.startEncounter = function() {
  // select random enemy
  const enemies = [
    { id:'babyDragon', name:'Baby Dragon', hp:20, atk:6 },
    { id:'wyvern', name:'Forest Wyvern', hp:28, atk:8 }
  ];
  const enemy = Phaser.Utils.Array.GetRandom(enemies);
  this.scene.pause();
  this.scene.launch('BattleScene', { enemy: enemy, from: 'WorldScene' });
};

/* Save/Load */
WorldScene.prototype.saveGame = function() {
  const data = {
    coins: this.state.coins,
    inventory: this.state.inventory,
    quest: this.state.quest,
    playerPos: { x: Math.floor(this.player.x/16), y: Math.floor(this.player.y/16) },
    stage: this.state.stage
  };
  localStorage.setItem('gb_rpg_save', JSON.stringify(data));
};
WorldScene.prototype.loadGame = function() {
  const s = JSON.parse(localStorage.getItem('gb_rpg_save') || "null");
  if (!s) { alert('No save found'); return; }
  this.state.coins = s.coins;
  this.state.inventory = s.inventory;
  this.state.quest = s.quest;
  this.state.playerPos = s.playerPos;
  this.state.stage = s.stage;
  document.getElementById('coinCount').innerText = this.state.coins;
  document.getElementById('questState').innerText = this.state.quest;
  this.player.x = this.state.playerPos.x * 16;
  this.player.y = this.state.playerPos.y * 16;
  this.scene.get('UIScene').updateInv(this.state.inventory);
};

/* ===========================
   BattleScene: 턴제 전투
   =========================== */
function BattleScene() { Phaser.Scene.call(this, { key:'BattleScene' }); }
BattleScene.prototype = Object.create(Phaser.Scene.prototype);
BattleScene.prototype.constructor = BattleScene;

BattleScene.prototype.init = function(data) {
  this.enemyData = data.enemy;
  this.fromScene = data.from;
};
BattleScene.prototype.create = function() {
  // background overlay
  this.cameras.main.setBackgroundColor('#081820');
  this.add.rectangle(0,0, GAME_WIDTH, GAME_HEIGHT, 0x081820).setOrigin(0);

  // simple HUD areas
  this.add.text(12, 12, 'Battle!', { font:'16px monospace', fill:'#E0F8D0' });

  // Player stats (simple)
  this.playerHP = 30;
  this.playerMax = 30;
  this.enemyHP = this.enemyData.hp;
  this.enemyMax = this.enemyData.hp;

  // show enemy box
  this.enemyText = this.add.text(12, 40, `${this.enemyData.name} HP: ${this.enemyHP}/${this.enemyMax}`, { font:'12px monospace', fill:'#ffd' });

  // show player box
  this.playerText = this.add.text(12, 160, `You HP: ${this.playerHP}/${this.playerMax}`, { font:'12px monospace', fill:'#ffd' });

  // action menu
  this.actions = ['Attack','Item','Run'];
  this.actionIndex = 0;
  this.actionText = this.add.text(12, 200, this.getActionMenu(), { font:'12px monospace', fill:'#E0F8D0' });

  // keys
  this.keys = this.input.keyboard.addKeys({ up:Phaser.Input.Keyboard.KeyCodes.UP, down:Phaser.Input.Keyboard.KeyCodes.DOWN, confirm:Phaser.Input.Keyboard.KeyCodes.Z });

  this.input.keyboard.on('keydown', (e)=> {
    if (e.keyCode === Phaser.Input.Keyboard.KeyCodes.UP) { this.actionIndex = Phaser.Math.Wrap(this.actionIndex-1, 0, this.actions.length); this.actionText.setText(this.getActionMenu()); }
    if (e.keyCode === Phaser.Input.Keyboard.KeyCodes.DOWN) { this.actionIndex = Phaser.Math.Wrap(this.actionIndex+1, 0, this.actions.length); this.actionText.setText(this.getActionMenu()); }
    if (e.keyCode === Phaser.Input.Keyboard.KeyCodes.Z) { this.doAction(this.actions[this.actionIndex]); }
  });
};

BattleScene.prototype.getActionMenu = function(){
  let s = '>';
  for (let i=0;i<this.actions.length;i++){
    s += (i===this.actionIndex ? ' ['+this.actions[i]+']' : '  '+this.actions[i]) + '\\n';
  }
  return s;
};

BattleScene.prototype.doAction = function(action) {
  if (action === 'Attack') {
    // player attacks
    const dmg = Phaser.Math.Between(4,8);
    this.enemyHP -= dmg; if (this.enemyHP < 0) this.enemyHP = 0;
    this.enemyText.setText(`${this.enemyData.name} HP: ${this.enemyHP}/${this.enemyMax}`);
    this.log('You hit for '+dmg);

    if (this.enemyHP <= 0) return this.win();
    // enemy turn
    this.time.delayedCall(700, ()=> this.enemyTurn(), [], this);
  } else if (action === 'Item') {
    // use potion if available
    const ws = this.scene.get('WorldScene');
    const inv = ws.state.inventory;
    const idx = inv.indexOf('Potion');
    if (idx >= 0) {
      this.playerHP = Math.min(this.playerMax, this.playerHP + 15);
      inv.splice(idx,1);
      this.playerText.setText(`You HP: ${this.playerHP}/${this.playerMax}`);
      this.scene.get('UIScene').updateInv(inv);
      this.log('Used a Potion');
      this.time.delayedCall(700, ()=> this.enemyTurn(), [], this);
    } else {
      this.log('No potion!');
    }
  } else if (action === 'Run') {
    if (Math.random() < 0.5) {
      this.log('Escaped!');
      this.time.delayedCall(400, ()=> this.endBattle(false), [], this);
    } else {
      this.log('Couldn\\'t escape!');
      this.time.delayedCall(700, ()=> this.enemyTurn(), [], this);
    }
  }
};

BattleScene.prototype.enemyTurn = function() {
  // enemy attacks
  const dmg = Phaser.Math.Between( this.enemyData.atk-2, this.enemyData.atk+2 );
  this.playerHP -= dmg; if (this.playerHP < 0) this.playerHP = 0;
  this.playerText.setText(`You HP: ${this.playerHP}/${this.playerMax}`);
  this.log(this.enemyData.name + ' hits for ' + dmg);
  if (this.playerHP <= 0) return this.lose();
};

BattleScene.prototype.win = function() {
  this.log('You defeated ' + this.enemyData.name + '!');
  // reward coins and possible item
  const ws = this.scene.get('WorldScene');
  ws.state.coins += Phaser.Math.Between(1,4);
  document.getElementById('coinCount').innerText = ws.state.coins;
  this.time.delayedCall(800, ()=> this.endBattle(true), [], this);
};

BattleScene.prototype.lose = function() {
  this.log('You were defeated...');
  this.time.delayedCall(800, ()=> this.endBattle(false), [], this);
};

BattleScene.prototype.endBattle = function(win) {
  // close and resume world
  this.scene.stop();
  const ws = this.scene.get('WorldScene');
  ws.scene.resume();
};

BattleScene.prototype.log = function(txt) {
  // temporary display
  if (this.infoText) this.infoText.destroy();
  this.infoText = this.add.text(12, 100, txt, { font:'12px monospace', fill:'#fff' });
};

/* ===========================
   Start: attach UI and run
   =========================== */
window.addEventListener('load', ()=> {
  // nothing extra
});
</script>

</body>
</html>

